{
    "ast": null,
    "code": "import _asyncToGenerator from \"D:/Work/RadicalLedger_projects/SIOP/did-siop-browser-ext/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/// <reference types=\"chrome\"/>\n/// <reference types=\"firefox-webext-browser\"/>\nimport { Provider, ERROR_RESPONSES } from 'did-siop';\nimport * as queryString from 'query-string';\nimport { STORAGE_KEYS } from '../const';\nimport { authenticate, checkExtAuthenticationState, initExtAuthentication } from './AuthUtils';\nimport { encrypt, decrypt } from './CryptoUtils';\nimport { DidCreators } from './DidUtils';\nlet provider;\nlet signingInfoSet = [];\nlet loggedInState = undefined;\nlet runtime;\nlet tabs;\n\ntry {\n  runtime = browser.runtime;\n  tabs = browser.tabs;\n} catch (err) {\n  try {\n    runtime = chrome.runtime;\n    tabs = chrome.tabs;\n  } catch (err) {\n    console.log('DID-SIOP ERROR: No runtime detected');\n  }\n}\n\nfunction checkSigning() {\n  return _checkSigning.apply(this, arguments);\n}\n\nfunction _checkSigning() {\n  _checkSigning = _asyncToGenerator(function* () {\n    try {\n      if (!provider) {\n        let did = decrypt(localStorage.getItem(STORAGE_KEYS.userDID), loggedInState);\n        provider = yield Provider.getProvider(did);\n      }\n\n      if (signingInfoSet.length < 1) {\n        signingInfoSet = JSON.parse(decrypt(localStorage.getItem(STORAGE_KEYS.signingInfoSet), loggedInState));\n\n        if (!signingInfoSet) {\n          signingInfoSet = [];\n        } else {\n          signingInfoSet.forEach(info => {\n            provider.addSigningParams(info.key);\n          });\n        }\n      }\n    } catch (err) {\n      provider = undefined;\n      signingInfoSet = [];\n      throw err;\n    }\n  });\n  return _checkSigning.apply(this, arguments);\n}\n\nruntime.onMessage.addListener(function (request, sender, sendResponse) {\n  if (!sender.tab) {\n    switch (request.task) {\n      case 0\n      /* TASKS.CHANGE_DID */\n      :\n        {\n          changeDID(request.did).then(result => {\n            sendResponse({\n              result: result\n            });\n          }).catch(err => {\n            sendResponse({\n              err: err.message\n            });\n          });\n          break;\n        }\n\n      case 1\n      /* TASKS.ADD_KEY */\n      :\n        {\n          addKey(request.keyInfo).then(result => {\n            sendResponse({\n              result: result\n            });\n          }).catch(err => {\n            sendResponse({\n              err: err.message\n            });\n          });\n          break;\n        }\n\n      case 2\n      /* TASKS.REMOVE_KEY */\n      :\n        {\n          removeKey(request.kid).then(result => {\n            sendResponse({\n              result: result\n            });\n          }).catch(err => {\n            sendResponse({\n              err: err.message\n            });\n          });\n          break;\n        }\n\n      case 4\n      /* TASKS.CHECK_LOGIN_STATE */\n      :\n        {\n          sendResponse({\n            result: checkLoggedInState()\n          });\n          break;\n        }\n\n      case 5\n      /* TASKS.LOGIN */\n      :\n        {\n          sendResponse({\n            result: login(request.password)\n          });\n          break;\n        }\n\n      case 6\n      /* TASKS.LOGOUT */\n      :\n        {\n          sendResponse({\n            result: logout()\n          });\n          break;\n        }\n\n      case 7\n      /* TASKS.CHECK_EXT_AUTHENTICATION */\n      :\n        {\n          let result = checkExtAuthenticationState();\n          sendResponse({\n            result: result\n          });\n          break;\n        }\n\n      case 8\n      /* TASKS.INIT_EXT_AUTHENTICATION */\n      :\n        {\n          sendResponse({\n            result: initExtAuthentication(request.password)\n          });\n          break;\n        }\n\n      case 9\n      /* TASKS.CHANGE_EXT_AUTHENTICATION */\n      :\n        {\n          sendResponse({\n            result: changePassword(request.oldPassword, request.newPassword)\n          });\n          break;\n        }\n\n      case 10\n      /* TASKS.GET_IDENTITY */\n      :\n        {\n          let did = '';\n          let keys = '';\n\n          try {\n            let encryptedDID = localStorage.getItem(STORAGE_KEYS.userDID);\n            let encryptedSigningInfo = localStorage.getItem(STORAGE_KEYS.signingInfoSet);\n\n            if (encryptedDID) {\n              did = decrypt(encryptedDID, loggedInState);\n              keys = decrypt(encryptedSigningInfo, loggedInState);\n            }\n          } catch (err) {}\n\n          sendResponse({\n            did,\n            keys\n          });\n          break;\n        }\n\n      case 11\n      /* TASKS.GET_REQUESTS */\n      :\n        {\n          sendResponse({\n            didSiopRequests: getRequests()\n          });\n          break;\n        }\n\n      case 3\n      /* TASKS.PROCESS_REQUEST */\n      :\n        {\n          processRequest(request.did_siop_index, request.confirmation, request.vp_token).then(result => {\n            sendResponse({\n              result: result\n            });\n          }).catch(err => {\n            console.log(\"Error in processing request : \", err.message);\n            sendResponse({\n              err: err.message\n            });\n          });\n          break;\n        }\n\n      case 13\n      /* TASKS.CREATE_DID */\n      :\n        {\n          createDID(request.method, request.data).then(result => {\n            sendResponse({\n              result: {\n                did: result.did,\n                kid: result.kid,\n                keyString: result.privateKey\n              }\n            });\n          }).catch(err => {\n            sendResponse({\n              err: err.message\n            });\n          });\n        }\n    }\n  } else {\n    switch (request.task) {\n      case 12\n      /* TASKS.MAKE_REQUEST */\n      :\n        {\n          try {\n            let result = addRequest(request.did_siop);\n            sendResponse({\n              result\n            });\n          } catch (err) {\n            sendResponse({\n              err: err.message\n            });\n          }\n\n          break;\n        }\n    }\n  }\n\n  return true;\n});\n\nfunction checkLoggedInState() {\n  if (loggedInState) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction login(password) {\n  if (authenticate(password)) {\n    loggedInState = password;\n    return true;\n  }\n\n  return false;\n}\n\nfunction logout() {\n  if (loggedInState) {\n    loggedInState = undefined;\n    return true;\n  }\n\n  return false;\n}\n\nfunction changePassword(oldPassword, newPassword) {\n  if (login(oldPassword)) {\n    let changed = initExtAuthentication(newPassword);\n\n    if (changed) {\n      let encryptedDID = localStorage.getItem(STORAGE_KEYS.userDID);\n      let encryptedSigningInfo = localStorage.getItem(STORAGE_KEYS.signingInfoSet);\n\n      if (encryptedDID) {\n        let didRecrypted = encrypt(decrypt(encryptedDID, oldPassword), newPassword);\n        localStorage.setItem(STORAGE_KEYS.userDID, didRecrypted);\n      }\n\n      if (encryptedSigningInfo) {\n        let keysRecrypted = encrypt(decrypt(encryptedSigningInfo, oldPassword), newPassword);\n        localStorage.setItem(STORAGE_KEYS.signingInfoSet, keysRecrypted);\n      }\n\n      loggedInState = newPassword;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction changeDID(_x) {\n  return _changeDID.apply(this, arguments);\n}\n\nfunction _changeDID() {\n  _changeDID = _asyncToGenerator(function* (did) {\n    try {\n      let newProvider = yield Provider.getProvider(did);\n      provider = newProvider;\n      let encryptedDID = encrypt(did, loggedInState);\n      localStorage.setItem(STORAGE_KEYS.userDID, encryptedDID);\n      signingInfoSet = [];\n      let encryptedSigningInfo = encrypt(JSON.stringify(signingInfoSet), loggedInState);\n      localStorage.setItem(STORAGE_KEYS.signingInfoSet, encryptedSigningInfo);\n      return 'Identity changed successfully';\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  });\n  return _changeDID.apply(this, arguments);\n}\n\nfunction addKey(_x2) {\n  return _addKey.apply(this, arguments);\n}\n\nfunction _addKey() {\n  _addKey = _asyncToGenerator(function* (key) {\n    try {\n      yield checkSigning();\n      let kid = provider.addSigningParams(key);\n      signingInfoSet.push({\n        key: key,\n        kid: kid\n      });\n      let encryptedSigningInfo = encrypt(JSON.stringify(signingInfoSet), loggedInState);\n      localStorage.setItem(STORAGE_KEYS.signingInfoSet, encryptedSigningInfo);\n      return kid;\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  });\n  return _addKey.apply(this, arguments);\n}\n\nfunction removeKey(_x3) {\n  return _removeKey.apply(this, arguments);\n}\n\nfunction _removeKey() {\n  _removeKey = _asyncToGenerator(function* (kid) {\n    try {\n      yield checkSigning();\n      provider.removeSigningParams(kid);\n      signingInfoSet = signingInfoSet.filter(key => {\n        return key.kid !== kid;\n      });\n      let encryptedSigningInfo = encrypt(JSON.stringify(signingInfoSet), loggedInState);\n      localStorage.setItem(STORAGE_KEYS.signingInfoSet, encryptedSigningInfo);\n      return 'Key removed successfully';\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  });\n  return _removeKey.apply(this, arguments);\n}\n\nfunction processRequest(_x4, _x5, _x6) {\n  return _processRequest.apply(this, arguments);\n}\n\nfunction _processRequest() {\n  _processRequest = _asyncToGenerator(function* (request_index, confirmation, vp_token) {\n    let processError;\n    let request = getRequestByIndex(request_index).request;\n\n    if (queryString.parseUrl(request).url === 'openid://') {\n      try {\n        yield checkSigning();\n\n        try {\n          if (confirmation) {\n            if (vp_token) {\n              let new_request = yield generateRequestWithVP(queryString.parseUrl(request).query.redirect_uri, vp_token);\n              if (new_request) request = new_request;\n            } //console.log(JSON.parse(Buffer.from(request.split('.')[1], 'base64').toString()))\n\n\n            let vps = {\n              vp_token: vp_token,\n              _vp_token: {}\n            };\n\n            try {\n              let decodedRequest = yield provider.validateRequest(request); // let response = vp_token ? await provider.generateResponseWithVPData(decodedRequest.payload, 5000, vps) : await provider.generateResponse(decodedRequest.payload);\n\n              try {\n                let response = yield provider.generateResponse(decodedRequest.payload);\n                console.log(\"decodedRequest.payload\", decodedRequest.payload);\n\n                if (decodedRequest.payload.response_mode && decodedRequest.payload.response_mode === 'post') {\n                  try {\n                    yield postToRP(decodedRequest.payload.redirect_uri, response);\n                  } catch (e) {\n                    console.log(\"PostToRP failed\", e);\n                  }\n                } else {\n                  let uri = decodedRequest.payload.redirect_uri + '#' + response;\n                  tabs.create({\n                    url: uri\n                  });\n                }\n\n                console.log('Sent response to ' + decodedRequest.payload.redirect_uri + ' with id_token: ' + response);\n                removeRequest(request_index);\n                return 'Successfully logged into ' + decodedRequest.payload.redirect_uri;\n              } catch (err) {\n                processError = err;\n              }\n            } catch (err) {\n              let uri = queryString.parseUrl(request).query.client_id;\n\n              if (uri) {\n                uri = uri + '#' + provider.generateErrorResponse(err.message);\n                tabs.create({\n                  url: uri\n                });\n                removeRequest(request_index);\n              } else {\n                processError = new Error('invalid redirect url');\n              }\n            }\n          } else {\n            let uri = queryString.parseUrl(request).query.client_id;\n\n            if (uri) {\n              uri = uri + '#' + provider.generateErrorResponse(ERROR_RESPONSES.access_denied.err.message);\n              tabs.create({\n                url: uri\n              });\n              removeRequest(request_index);\n            } else {\n              processError = new Error('invalid redirect url');\n            }\n          }\n        } catch (err) {\n          processError = err;\n        }\n      } catch (err) {\n        processError = new Error('Error retrieving credentials. Please check Identity and Signing keys');\n      }\n    }\n\n    if (processError) throw processError;\n  });\n  return _processRequest.apply(this, arguments);\n}\n\nconst generateRequestWithVP = (redirect_url, vp_token) => {\n  return new Promise(resolve => {\n    let url = new URL(redirect_url);\n    fetch(`${url.origin}/get_request_object_vp/vp`, {\n      method: \"POST\",\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        vp_token\n      })\n    }).then(res => res.json()).then(data => {\n      resolve(data.reqObj);\n    }).catch(err => {\n      resolve(null);\n    });\n  });\n};\n\nfunction postToRP(_x7, _x8) {\n  return _postToRP.apply(this, arguments);\n}\n\nfunction _postToRP() {\n  _postToRP = _asyncToGenerator(function* (redirectUri, response) {\n    const rawResponse = yield fetch(redirectUri, {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        \"token\": response\n      })\n    });\n\n    try {\n      const content = yield rawResponse.json();\n      console.log(content);\n    } catch (e) {\n      console.log(e);\n    }\n  });\n  return _postToRP.apply(this, arguments);\n}\n\nfunction getRequests() {\n  let storedRequests = localStorage.getItem(STORAGE_KEYS.requests);\n  if (!storedRequests) storedRequests = '[]';\n  return JSON.parse(storedRequests);\n}\n\nfunction getRequestByIndex(index) {\n  let storedRequests = localStorage.getItem(STORAGE_KEYS.requests);\n  if (!storedRequests) storedRequests = '[]';\n  storedRequests = JSON.parse(storedRequests);\n  return storedRequests.filter(sr => {\n    return sr.index == index;\n  })[0];\n}\n\nfunction addRequest(request) {\n  try {\n    if (queryString.parseUrl(request).url != 'openid://') throw new Error('Invalid request');\n    let storedRequests = localStorage.getItem(STORAGE_KEYS.requests);\n    if (!storedRequests) storedRequests = '[]';\n    storedRequests = JSON.parse(storedRequests);\n    let index = 0;\n\n    for (let i = 0; i < storedRequests.length; i++) {\n      if (storedRequests[i].index > index) index = storedRequests[i].index;\n    }\n\n    ++index;\n    let client_id = queryString.parseUrl(request).query.client_id;\n    storedRequests.push({\n      index,\n      client_id,\n      request\n    });\n    localStorage.setItem(STORAGE_KEYS.requests, JSON.stringify(storedRequests));\n    return true;\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction removeRequest(index) {\n  let storedRequests = localStorage.getItem(STORAGE_KEYS.requests);\n  if (!storedRequests) storedRequests = '[]';\n  storedRequests = JSON.parse(storedRequests);\n  let request = storedRequests.filter(sr => {\n    return sr.index == index;\n  })[0];\n  storedRequests = storedRequests.filter(sr => {\n    return sr.index != index;\n  });\n  localStorage.setItem(STORAGE_KEYS.requests, JSON.stringify(storedRequests));\n  return request.request;\n}\n\nfunction createDID(_x9, _x10) {\n  return _createDID.apply(this, arguments);\n}\n\nfunction _createDID() {\n  _createDID = _asyncToGenerator(function* (method, data) {\n    try {\n      const create = DidCreators[method];\n      let identity = yield create(data);\n      yield changeDID(identity.did);\n      let kid = yield addKey(identity.privateKey);\n      return {\n        did: identity.did,\n        kid,\n        privateKey: identity.privateKey\n      };\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  });\n  return _createDID.apply(this, arguments);\n}",
    "map": null,
    "metadata": {},
    "sourceType": "module"
}
